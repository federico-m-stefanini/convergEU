---
output:
  html_document:
    css: EUF.css
params:
   time_0: NA
   time_t: NA
   timeName: NA
   workingDF: NA 
   country: NA
   otherCountries: c(NA,NA)
   indiType: NA
   aggregation: NA
   x_angle:  45
   dataNow:  NA
   auth: NA
   outFile: NA
   outDir: NA
   indiName: NA
   workTB: !r emp_20_64_MS
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE,eval=TRUE}

library(convergEU)
library(knitr)
library(tibble)
library(devtools)
library(tidyverse)
library(gridExtra)
library(eurostat)
library(purrr)
library(ggplot2)
library(dplyr)
library(tidyr)
library(ggplot2)
library(kableExtra)
library(caTools)
library(broom)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  prompt= TRUE,
  fig.width = 7,
  fig.height = 5,
  echo=FALSE,
  message = FALSE,
  warning = FALSE,
  eval=TRUE
)


```


```{r debug1,echo=FALSE,eval=FALSE,warning=FALSE,message=FALSE}
params <- list(workingDF = NA, time_0 = 2005, time_t = 2010, timeName = "time", 
    country = "IT", otherCountries = "NA", indiType = "highBest", 
    indiName = "emp_20_64_MS", aggregation = "EU27", x_angle = 45, 
    dataNow = structure(1602310206.79617, class = c("POSIXct", 
    "POSIXt")), auth = "A.Student", outFile = "primoTest", outDir = "/tmp/RtmpFwRXrp", 
    workTB = structure(list(time = c(2002, 2003, 2004, 2005, 
    2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 
    2016, 2017, 2018), AT = c(70.9, 71.3, 68.4, 70.4, 71.6, 72.8, 
    73.8, 73.4, 73.9, 74.2, 74.4, 74.6, 74.2, 74.3, 74.8, 75.4, 
    76.2), BE = c(64.7, 64.5, 65.8, 66.5, 66.5, 67.7, 68, 67.1, 
    67.6, 67.3, 67.2, 67.2, 67.3, 67.2, 67.7, 68.5, 69.7), BG = c(56.5, 
    58.7, 61.2, 61.9, 65.1, 68.4, 70.7, 68.8, 64.7, 62.9, 63, 
    63.5, 65.1, 67.1, 67.7, 71.3, 72.4), CY = c(75.1, 75.4, 75.7, 
    74.4, 75.8, 76.8, 76.5, 75.3, 75, 73.4, 70.2, 67.2, 67.6, 
    67.9, 68.7, 70.8, 73.9), CZ = c(71.7, 71, 70.1, 70.7, 71.2, 
    72, 72.4, 70.9, 70.4, 70.9, 71.5, 72.5, 73.5, 74.8, 76.7, 
    78.5, 79.9), DE = c(68.8, 68.4, 67.9, 69.4, 71.1, 72.9, 74, 
    74.2, 75, 76.5, 76.9, 77.3, 77.7, 78, 78.6, 79.2, 79.9), 
        DK = c(78.3, 77.4, 78.1, 78, 79.4, 79, 78.7, 76.1, 74.9, 
        74.8, 74.3, 74.3, 74.7, 75.4, 76, 76.6, 77.5), EE = c(68.3, 
        69.1, 70.2, 72, 75.9, 76.9, 77.1, 70, 66.8, 70.6, 72.2, 
        73.3, 74.3, 76.5, 76.6, 78.7, 79.5), EL = c(62.8, 63.8, 
        64.3, 64.4, 65.6, 65.8, 66.3, 65.6, 63.8, 59.6, 55, 52.9, 
        53.3, 54.9, 56.2, 57.8, 59.5), ES = c(63.2, 64.3, 65.2, 
        67.5, 69, 69.7, 68.5, 64, 62.8, 62, 59.6, 58.6, 59.9, 
        62, 63.9, 65.5, 67), FI = c(73.2, 72.9, 72.5, 73, 73.9, 
        74.8, 75.8, 73.5, 73, 73.8, 74, 73.3, 73.1, 72.9, 73.4, 
        74.2, 76.3), FR = c(68.6, 69.7, 69.2, 69.4, 69.4, 69.9, 
        70.5, 69.5, 69.3, 69.2, 69.4, 69.5, 69.2, 69.5, 70, 70.6, 
        71.3), HR = c(57.9, 58.4, 59.7, 60, 60.6, 63.9, 64.9, 
        64.2, 62.1, 59.8, 58.1, 57.2, 59.2, 60.6, 61.4, 63.6, 
        65.2), HU = c(61.4, 62.4, 62, 62.2, 62.6, 62.3, 61.5, 
        60.1, 59.9, 60.4, 61.6, 63, 66.7, 68.9, 71.5, 73.3, 74.4
        ), IE = c(70.8, 70.4, 71, 72.6, 73.4, 75.1, 73.5, 68, 
        65.5, 64.6, 64.5, 66.5, 68.1, 69.9, 71.4, 73, 74.1), 
        IT = c(59.2, 60.1, 61.7, 61.5, 62.4, 62.7, 62.9, 61.6, 
        61, 61, 60.9, 59.7, 59.9, 60.5, 61.6, 62.3, 63), LT = c(68, 
        70.7, 69.6, 70.7, 71.3, 72.7, 72, 67, 64.3, 66.9, 68.5, 
        69.9, 71.8, 73.3, 75.2, 76, 77.8), LU = c(68.4, 67.2, 
        67.7, 69, 69.1, 69.6, 68.8, 70.4, 70.7, 70.1, 71.4, 71.1, 
        72.1, 70.9, 70.7, 71.5, 72.1), LV = c(66.3, 67.4, 67.4, 
        69.1, 73.2, 75.2, 75.4, 66.6, 64.3, 66.3, 68.1, 69.7, 
        70.7, 72.5, 73.2, 74.8, 76.8), MT = c(58.2, 57.8, 57.3, 
        57.4, 57.9, 58.6, 59.2, 59, 60.1, 61.6, 63.9, 66.2, 67.9, 
        69, 71.1, 73, 75.5), NL = c(75.8, 75.3, 74.9, 72.7, 73.7, 
        75.5, 76.9, 76.8, 76.2, 76.4, 76.6, 75.9, 75.4, 76.4, 
        77.1, 78, 79.2), PL = c(57.7, 57.3, 57, 58.3, 60.1, 62.7, 
        65, 64.9, 64.3, 64.5, 64.7, 64.9, 66.5, 67.8, 69.3, 70.9, 
        72.2), PT = c(74.1, 73, 72.6, 72.2, 72.6, 72.5, 73.1, 
        71.1, 70.3, 68.8, 66.3, 65.4, 67.6, 69.1, 70.6, 73.4, 
        75.4), RO = c(64.3, 64.8, 64.7, 63.6, 64.8, 64.4, 64.4, 
        63.5, 64.8, 63.8, 64.8, 64.7, 65.7, 66, 66.3, 68.8, 69.9
        ), SE = c(78.8, 78.5, 77.8, 78.1, 78.8, 80.1, 80.4, 78.3, 
        78.1, 79.4, 79.4, 79.8, 80, 80.5, 81.2, 81.8, 82.6), 
        SI = c(70, 68.1, 71, 71.1, 71.5, 72.4, 73, 71.9, 70.3, 
        68.4, 68.3, 67.2, 67.7, 69.1, 70.1, 73.4, 75.4), SK = c(63.2, 
        65, 63.5, 64.5, 66, 67.2, 68.8, 66.4, 64.6, 65, 65.1, 
        65, 65.9, 67.7, 69.8, 71.1, 72.4), UK = c(74.3, 74.7, 
        74.9, 75.2, 75.2, 75.2, 75.2, 73.9, 73.5, 73.5, 74.1, 
        74.8, 76.2, 76.8, 77.5, 78.2, 78.7)), class = c("spec_tbl_df", 
    "tbl_df", "tbl", "data.frame"), row.names = c(NA, -17L), spec = structure(list(
        cols = list(time = structure(list(), class = c("collector_double", 
        "collector")), AT = structure(list(), class = c("collector_double", 
        "collector")), BE = structure(list(), class = c("collector_double", 
        "collector")), BG = structure(list(), class = c("collector_double", 
        "collector")), CY = structure(list(), class = c("collector_double", 
        "collector")), CZ = structure(list(), class = c("collector_double", 
        "collector")), DE = structure(list(), class = c("collector_double", 
        "collector")), DK = structure(list(), class = c("collector_double", 
        "collector")), EE = structure(list(), class = c("collector_double", 
        "collector")), EL = structure(list(), class = c("collector_double", 
        "collector")), ES = structure(list(), class = c("collector_double", 
        "collector")), FI = structure(list(), class = c("collector_double", 
        "collector")), FR = structure(list(), class = c("collector_double", 
        "collector")), HR = structure(list(), class = c("collector_double", 
        "collector")), HU = structure(list(), class = c("collector_double", 
        "collector")), IE = structure(list(), class = c("collector_double", 
        "collector")), IT = structure(list(), class = c("collector_double", 
        "collector")), LT = structure(list(), class = c("collector_double", 
        "collector")), LU = structure(list(), class = c("collector_double", 
        "collector")), LV = structure(list(), class = c("collector_double", 
        "collector")), MT = structure(list(), class = c("collector_double", 
        "collector")), NL = structure(list(), class = c("collector_double", 
        "collector")), PL = structure(list(), class = c("collector_double", 
        "collector")), PT = structure(list(), class = c("collector_double", 
        "collector")), RO = structure(list(), class = c("collector_double", 
        "collector")), SE = structure(list(), class = c("collector_double", 
        "collector")), SI = structure(list(), class = c("collector_double", 
        "collector")), SK = structure(list(), class = c("collector_double", 
        "collector")), UK = structure(list(), class = c("collector_double", 
        "collector"))), default = structure(list(), class = c("collector_guess", 
        "collector")), skip = 1), class = "col_spec")))
```
 


<br>
<!-- center -->
<img src="eurofound.jpg" width=248px height=163px>
<!-- /center -->
<br><br>




# Country fiche 


This fiche shows the investigation of upward convergence in a particular Member State 
and its dynamics, compared to the other countries selected. The analysis is performed using 
the methodological framework of Eurofound (2018), where upward convergence is the process 
in which Member States improve their performance in relation to a particular outcome or 
policy objective together with a decrease in disparities among them. 

<br>

### Fiche info 
   
Today: `r params$dataNow`    
R Package: <a href='https://cran.r-project.org/package=convergEU'> **convergEU** </a>   
Indicator: *`r params$indiName`*  
Indicator type: *`r params$indiType`*  
Country of reference: *`r params$country`*      
Other selected countries: *`r paste(eval(parse(text=params$otherCountries)),collapse=", ")`*  
Aggregation: *`r params$aggregation`*  
Time window:  *`r params$timeName`* from *`r as.numeric(params$time_0)`* to *`r as.numeric(params$time_t)`*   
Author: *`r params$auth`*      

   
<br>   
   
   


```{r dataInit,echo=F,eval=T}
# to save into a out-file
out_packed_list <- list()
out_packed_list$params <- params
timeName <- params$timeName
seleCountry <- params$country


myx_angle <-  params$x_angle
ptime_0 <-  as.numeric(params$time_0)
ptime_t <-  as.numeric(params$time_t)
indiName <- params$indiName
indiType <- params$indiType
if(is.na(indiType))stop("Error: indicator type not available.")

out_packed_name <- file.path(params$outDir,
                             paste0(params$outFile,
                                    '-workspace.RData'))


wkDF0 <-  params$workTB



# filtering
wkDF0 <- dplyr::filter(wkDF0, (.data[[timeName]]   <= ptime_t) & (.data[[timeName]] >= ptime_0))

otherCountries <-  eval(parse(text= params$otherCountries ))
if(is.na(otherCountries[1]) && params$aggregation =="custom"){
   otherCountries <- setdiff(names(wkDF0),timeName)
}else if(is.na(otherCountries[1]) && params$aggregation !="custom"){
   otherCountries <- convergEU_glb()[[params$aggregation]]$memberStates$codeMS
}
otherCountries <- setdiff(otherCountries,seleCountry)


if( !(params$aggregation %in% 
      c( convergEU_glb()$labels_clusters,"custom"))){
  stop("Error: wrong aggregation selected!!\nLook into convergEU_glb()");
  };

if(params$aggregation != "custom"){
    nomiSele <- c(params$timeName,
               convergEU_glb()[[params$aggregation]]$memberStates$codeMS)
    nomiSeleExt <- c(params$timeName,
               convergEU_glb()[[params$aggregation]]$memberStates$MS)
    wkDF <-  dplyr::select(wkDF0,    all_of(nomiSele))
}else{
   # this is for "custom" selection
   nomiSele <- names(wkDF0)
   nomiSeleExt <- names(wkDF0)
   wkDF <-  wkDF0
}
## checking selection of MS
seleCount <- c(params$country, otherCountries)
if(length(setdiff(seleCount, nomiSele)) > 0){
        stop("Error: Member States  of interest outside the selected aggregation!!")
        };
## Uncomment this line below if you want to show the initial dataset
#  wkDF
```
  

 
 
 
 
 
 
 
 
 
 
 
 
<br><br>

###  Country time series and `r params$aggregation` aggregation


The graph gives an overview of the country performance compared to `r params$aggregation`. 



<br><br>

```{r}

outSig <- sigma_conv(wkDF, timeName = timeName,
           time_0 = ptime_0,  time_t = ptime_t) 
miniY <-  min(wkDF[,- which(names(wkDF) == timeName )])
maxiY <-  max(wkDF[,- which(names(wkDF) == timeName )])
estrattore<-  wkDF[[timeName]] >= ptime_0  &  wkDF[[timeName]] <= ptime_t
# to guarantee that timeName is "time"
names(outSig$res)[1]<-"time"
selettmp <- dplyr::filter(wkDF,estrattore)
ttmp <- cbind(outSig$res, dplyr::select(selettmp, -contains(timeName)))


# minimum and maximum values
tmpwkDF <- dplyr::filter(wkDF,estrattore)
rawDat <- dplyr::select(tmpwkDF, -contains(timeName))
ttmp <- dplyr::mutate(ttmp,serieMax =apply(rawDat,1,max))
ttmp <- dplyr::mutate(ttmp,serieMin =apply(rawDat,1,min))
```

```{r}
# build labels for minimum and maximum
ttmpeticheMin <-sapply(seq(1,length(ttmp$serieMin)),
          function(vx){
      estrattore <- ttmp$serieMin[vx] == rawDat[vx,]
      paste(names(rawDat)[estrattore],collapse="/")
})
ttmp <- dplyr::mutate(ttmp,eticheMin = ttmpeticheMin)

ttmpeticheMax <- sapply(seq(1,length(ttmp$serieMin)),
          function(vx){
      estrattore <- ttmp$serieMax[vx] == rawDat[vx,]
      paste(names(rawDat)[estrattore],collapse="/")
})
ttmp <- dplyr::mutate(ttmp,eticheMax = ttmpeticheMax)
```


```{r}
#1# revision with standard names  
myG2 <-  ggplot(ttmp) +  
         geom_line(aes(x= .data[[timeName]], y = .data[["mean"]],colour="black" )) +
          geom_point(aes(x=.data[[timeName]],y = .data[["mean"]],colour="black")) + 
          # add countries
          #6 aprile geom_line( aes( x = ttmp[,timeName], y = ttmp[[seleCountry]], 
          geom_line( aes( x = .data[[timeName]], y = .data[[seleCountry]], 
                          colour="red"),linetype="dotted") + 
          # 6 aprile geom_point( aes(x = ttmp[,timeName], y = ttmp[,seleCountry], colour="red")) +
          geom_point( aes(x = .data[[timeName]], y = .data[[seleCountry]], 
                          colour="red")) +
          # 6 aprileggplot2::scale_x_continuous(breaks = ttmp[,timeName],labels = ttmp[,timeName]) +
          ggplot2::scale_x_continuous(breaks = .data[[timeName]],
                                      labels = .data[[timeName]]) +
          ylim(c(miniY,maxiY)) + 
          xlab("Year") + 
          ylab("Indicator level") +
        ggplot2::geom_line(aes(x= .data[[timeName]],
                               y= .data[["serieMin"]],
                               colour = "blue" 
                               ),linetype="dashed") +
        ggplot2::geom_line(aes(x= .data[[timeName]],
                               y= .data[["serieMax"]],
                               colour = "blue" 
                               ),linetype="dashed") +
        ggplot2::annotate("text",
                        x = .data[["time"]], 
                        y = .data[["serieMax"]], 
                        label = paste(.data[[eticheMax]],"    "),
                        color ="navyblue",
                        angle=45) +
        ggplot2::annotate("text", 
                        x = .data[["time"]], 
                        y= .data[["serieMin"]], 
                        label = paste("    ",ttmp$eticheMin),
                        color ="navyblue",
                        angle=45)  +
       ggplot2::theme(
                 axis.text.x=ggplot2::element_text(
                 angle = myx_angle 
                 )) +
      scale_colour_manual("Series",
                      values=c("blue"="blue",
                               "red" = "red",
                               "black" = "black")
                      ,labels=c("blue" = "min/max",
                                "red" = seleCountry,
                                 "black"="mean")
                      ) + theme(legend.key.size = unit(1.3, "cm")) +
      guides(shape = FALSE, colour = guide_legend(
           override.aes = list(linetype =  c(
                                        "black"="F1",
                                        "blue"="45",
                                        "red"="13")
           ))) 
  
  
  
 

print(myG2)
# save to file
out_packed_list$EUave1 <- myG2
```



```{r,echo=F}
# averaging conditional to aggregation
if(params$aggregation != "custom"){
outMed <- average_clust(wkDF, timeName = params$timeName, 
              cluster = params$aggregation)$res[,c(timeName,params$aggregation)]
}else{
  outMed <- average_clust(wkDF, timeName = params$timeName, 
                          cluster = "all")$res[,c(timeName,"all")]
  
  vars2rename <- c(custom="all")
  outMed <- dplyr::rename(outMed, custom = all)
}
lastRowAverages <- nrow(outMed)
diffeAve <- as.numeric(outMed[lastRowAverages,params$aggregation]) - 
            as.numeric(outMed[1,params$aggregation])

diffeSeleCountry <- wkDF[lastRowAverages,params$country]-wkDF[1,params$country]
```


  * Change in  `r params$country`:    
      
      + Year `r ptime_0`:  `r as.numeric(wkDF[1,params$country])`   
      + Year `r ptime_t`:  `r as.numeric(wkDF[lastRowAverages, params$country])`          
      + Difference $\Delta$ between years: `r  diffeSeleCountry`    
  
  * Change in `r params$aggregation` average:   
  
      + Year `r ptime_0`, average:  `r as.numeric(outMed[1,params$aggregation])`   
      + Year `r ptime_t`, average:  `r as.numeric(outMed[lastRowAverages,params$aggregation])`          
      + Difference $\Delta$ between years: `r  diffeAve`    
   <br> 
   
     
 







<br><br>

###  Country time series compared to the other countries selected

The graph shows the times series trend of the selected Member States giving an
idea of the individual development of the countries selected. 

<br>

```{r,echo=FALSE,eval=T}
#  other countries forced to be present without missing values

    tmp2 <-  ttmp[, c(timeName,seleCountry,otherCountries)]
    tmp2$EU<-ttmp$mean
    tmp3 <-  tidyr::gather_(tmp2, gather_cols = c(seleCountry,otherCountries,"EU"), 
                            key_col = "Country",value_col="Indicator" )
    # rename EU as mean
    tmp3[ tmp3$Country == "EU","Country"] <-"mean"
    # colour red for reference country
    numCow <-  length(unique(tmp3$Country))
    tmp3$Country<- factor(tmp3$Country,levels=unique(tmp3$Country))
    tmp3$ColoreSC <-  "blue"
    tmp3$ColoreSC[tmp3$Country == seleCountry] <- "red" 
    tmp3$ColoreSC[tmp3$Country == "EU"] <- "black" 
    #
    tmp3$ShapeSC <-  as.numeric(tmp3$Country)
    #
    tmp3$LineSC <-  4
    tmp3$LineSC[tmp3$Country == seleCountry] <- 2 
    tmp3$LineSC[tmp3$Country == "EU"] <- 1 
    #
    tmp3$pointSize<-1.2
    
    myG3 <-   ggplot2::ggplot(tmp3,
                    aes(x=time, y =Indicator,colour=Country) )+  
        ggplot2::geom_line(
                  aes(colour =  Country)  
        ) +
        ggplot2::geom_point(
                      aes(colour=Country),
                      #6 april2020 #shape= tmp3$Country)  +
                      shape= 1)  +
        ggplot2::scale_x_continuous(
                     breaks = tmp3[,timeName],
                     labels = tmp3[,timeName]) +
        ggplot2::theme(
             axis.text.x=ggplot2::element_text(
             angle = myx_angle 
         )) +
        ylim(c(miniY,maxiY)) + 
        xlab("Year") +
        ylab(params$indiName)   

              
     
print(myG3)
# save to file
out_packed_list$EUave2 <- myG3


```

 


<!--  
cambiamenti di media
-->



```{r,echo=FALSE}

# averaging conditional to aggregation
outMed <- average_clust(wkDF,timeName = params$timeName, 
                        cluster="all")$res
outMed <- dplyr::rename(outMed, average = all)
lastRowAverages <- nrow(outMed)

diffeAve <- as.numeric(outMed[lastRowAverages,"average"]) - 
            as.numeric(outMed[1,"average"])
## nuova definizione 2 nov 2019
## highBest
if( (diffeAve > 0 )  &  (params$indiType =="highBest")){
  labelAveDelta <-  "upward change"
}else if((diffeAve == 0)  &  (params$indiType =="highBest")){
  labelAveDelta <- "unchanged"
}else if((diffeAve < 0)  &  (params$indiType =="highBest")) {
  labelAveDelta <- "downward change"
}
## lowBest
if( (diffeAve > 0 )  &  (params$indiType =="lowBest")){
  labelAveDelta <-  "downward change"
}else if((diffeAve == 0)  &  (params$indiType =="lowBest")){
  labelAveDelta <- "unchanged"
}else if((diffeAve < 0)  &  (params$indiType =="lowBest")) {
  labelAveDelta <- "upward change"
}



```



  * Change in average:    
  
      + Year `r ptime_0`, average:  `r as.numeric(outMed[1,"average"])`   
      + Year `r ptime_t`, average:  `r as.numeric(outMed[lastRowAverages,"average"])`         
      + Difference $\Delta$ between years: `r  diffeAve`    
   <br> 
  * Overall result (interpretation): **`r   labelAveDelta`**      
    
   







<br><br>

###  Alert indicator

This graph is useful in order to assess if the Member State's performance deviates significantly from the `r params$aggregation` average. This indicator has been created building on the EMCO and SPC methodology. 

```{r setupaleindica,echo=F}
curCountries <- params$country
if(!is.na(otherCountries[1])){
  curCountries <- c(curCountries, otherCountries)
}
altezzaG2 <- 3 + 7 * (length(curCountries)/30)

```


```{r}
## NOTE !!!!
## only calculations on subsequent years are supported.
## Time intervals of different lengths not supported
##
curCountries <- params$country
if(!is.na(otherCountries[1])){
  curCountries <- c(curCountries, otherCountries)
}
scobe_lvl <- scoreb_yrs(wkDF,timeName = timeName)$res$sco_level
# select subset of time
estrattore <- scobe_lvl[[timeName]] >= ptime_0  & scobe_lvl[[timeName]] <= ptime_t  
scobelvl <- scobe_lvl[estrattore,c(timeName,curCountries)]
# conversion
for(aux in curCountries){
  scobelvl[[aux]] <- c(-1,-0.5,0,0.5,1)[scobelvl[[aux]]]
}
final_TB <- tidyr::gather(scobelvl, key="Country",value="Level",all_of(curCountries))
```

```{r,fig.height=altezzaG2}
if(length(curCountries)>1){

myG_JAF <- ggplot(final_TB,
                  aes(x =  .data[[timeName]],
                      y = Level)) +
  ggplot2::facet_wrap(~ Country,ncol=2)+
  ggplot2::geom_line() + 
  ggplot2::geom_point() +
  ggplot2::theme(
         axis.text.x=ggplot2::element_text(
         angle = myx_angle 
         )) +
   ggplot2::scale_x_continuous(
     breaks = final_TB[[timeName]],
     labels = final_TB[[timeName]])  +
   ggplot2::scale_y_continuous(
     breaks =  c(-1,-0.5,0,0.5,1),
     labels = c(-1,-0.5,0,0.5,1), 
     limits= c( -1.25,1.25) )  +
  xlab("Years") +ylab("Indicator") +
geom_hline(yintercept=-1,colour="red",linetype="dotted")+
geom_hline(yintercept=-0.5,colour="red",linetype="dotted")+
geom_hline(yintercept=0,colour="red",linetype="dotted")+
geom_hline(yintercept=0.5,colour="red",linetype="dotted")+
geom_hline(yintercept= 1,colour="red",linetype="dotted")
}else{

myG_JAF <- ggplot(final_TB,aes(x = .data[[timeName]],
                    y = Level)) +
  ggplot2::geom_line() + 
  ggplot2::geom_point() +
  ggplot2::theme(
         axis.text.x=ggplot2::element_text(
         angle = myx_angle 
         )) +
   ggplot2::scale_x_continuous(
     breaks = final_TB[[timeName]],
     labels = final_TB[[timeName]])  +
   ggplot2::scale_y_continuous(
     breaks =  c(-1,-0.5,0,0.5,1),
     labels = c(-1,-0.5,0,0.5,1), 
     limits= c( -1.25,1.25) )  +
    xlab("Years") +ylab("Indicator") +
    geom_hline(yintercept=-1,colour="red",linetype="dotted")+
    geom_hline(yintercept=-0.5,colour="red",linetype="dotted")+
    geom_hline(yintercept=0,colour="red",linetype="dotted")+
    geom_hline(yintercept=0.5,colour="red",linetype="dotted")+
    geom_hline(yintercept= 1,colour="red",linetype="dotted")
  

}



print(myG_JAF)
out_packed_list$JAF <- myG_JAF

```
















<br><br>


### Selected Member States dynamics


This table is useful in order to assess if the Member State's performance deviates significantly from the `r params$aggregation` average.


```{r demeaGraphSet0,echo=FALSE,eval=T}
curCountries <- params$country
if(!is.na(otherCountries[1])){
  curCountries <- c(curCountries, otherCountries)
}
altezzaG0 <- 3 + 6 * (length(curCountries)/30)
#height was 6
```


```{r,fig.height=altezzaG0}
## NOTE !!!!
## only calculations on subsequent years are supported.
## Time intervals of different lengths not supported
##

curCountries <- params$country
if(!is.na(otherCountries[1])){
  curCountries <- c(curCountries, otherCountries)
}


obe_lvl <- scoreb_yrs(wkDF,timeName = timeName)$res$sco_level_num
# select subset of time
estrattore <- obe_lvl[[timeName]] >= ptime_0  & obe_lvl[[timeName]] <= ptime_t  
scobelvl <- obe_lvl[estrattore,c(timeName,curCountries)]


my_MS <- ms_dynam( scobelvl, 
                timeName = "time",
                displace = 0.25,
                displaceh = 0.45,
                dimeFontNum = 3,#5
                myfont_scale = 1.35,
                x_angle = 45,
                axis_name_y = "Countries",
                axis_name_x = "Time",
                alpha_color = 0.9,
                indiType = indiType
                )
print(my_MS)
out_packed_list$MSdyn <- my_MS
```








 
 
 
 
 
 




<br><br>

### Convergence and divergence patterns 
 

The table represents  convergence patterns of the
`r params$aggregation` countries in
 the chosen timeframe. The values in the table refer to the patterns shown in the graphical
 legend below.
 
<br>
  
 
 
<!-- pag 29  Eurofound convergence report 2018  --> 
 
<style>
.vertical-text {
	display: inline-block;
	overflow: hidden;
	width: 1.3em;
}
.vertical-text__inner {
	display: inline-block;
	white-space: nowrap;
	line-height: 1.5;
	transform: translate(0,100%) rotate(-90deg);
	transform-origin: 0 0;
}
/* This element stretches the parent to be square
   by using the mechanics of vertical margins  */
.vertical-text__inner:after {
	content: "";
	display: block;
	margin: -1.5em 0 100%;
}


body {
	font: 11px/1 Arial, sans-serif;
}

table {
	margin-top: 1em;
}
th,td {
	border: 1px solid;
	text-align:center;
	font-weight: normal;
	padding: 0.5em;
}
head{
   color: blue;
}
</style>

 
 

```{r, echo=FALSE}

testa_1 <- function(colonne_tot){
paste(  
"<table class=\"table table-striped table-condensed table-bordered\" style=\"font-size: 12px; width: auto !important; margin-center: auto; margin-right: auto;\"><thead>
<tr>
<th style=\"border-bottom:hidden\" colspan=\"1\"></th><th style=\"border-bottom:hidden; padding-bottom:0; padding-center:3px;padding-right:3px;text-align: center; color: #2676ba;\" colspan=\"",
colonne_tot-4,
"\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \"><span style=\"-webkit-transform: rotate(0deg); -moz-transform: rotate(0deg); -ms-transform: rotate(0deg); -o-transform: rotate(0deg); transform: rotate(0deg); display: inline-block;\">Yearly changes</span></div></th>
<th style=\"border-bottom:hidden; padding-bottom:0; padding-center:3px;padding-right:3px;text-align: center; color: #2676ba;\" colspan=\"3\"><div style=\"border-bottom: 1px solid #ddd; padding-bottom: 5px; \"><span style=\"-webkit-transform: rotate(0deg); -moz-transform: rotate(0deg); -ms-transform: rotate(0deg); -o-transform: rotate(0deg); transform: rotate(0deg); display: inline-block;\">Instances of convergence and divergence</span></div>
</th>
<th style=\"border-bottom:hidden\" colspan=\"1\"></th>
</tr>",  sep="")
  
}


testa_2bis <- function(etichetteH, etich_col_1r="First/Last"){

res <- "<tr><th style=\"text-align:left;\"> <div   style=\"color:#2676ba;\">Country</div> </th>";
for(aux in etichetteH){
  res <- paste(res,"<th style=\"text-align:center;\"><div class=\"vertical-text\">",
             "<div class=\"vertical-text__inner\" style=\"color:#2676ba;\">",
               aux,"</div></div> </th>", sep="",collapse="\n");
}  
res <- paste(res,  "<th style=\"text-align:center;\"> <div style=\"color:#2676ba;\">")  
# changed code
# res <- paste(res, "Catching up<br>(1) </div> </th> <th style=\"text-align:center;\"> ")
# res <- paste(res,"<div style=\"color:#2676ba;\"> Falling away <br>(9) </div> </th>")
# res <- paste(res, "<th style=\"text-align:center;\">  <div style=\"color:#2676ba;\">Diving  <br>(6)</div> </th>")
# new titles October 2020: number sign &#35; introduced
res <- paste(res, " &#35;(1) </div> </th> <th style=\"text-align:center;\"> ")
res <- paste(res,"<div style=\"color:#2676ba;\"> &#35;(9) </div> </th>")
res <- paste(res, "<th style=\"text-align:center;\">  <div style=\"color:#2676ba;\">&#35;(6)</div> </th>")
# end of changes

res <- paste(res,"<th style=\"text-align:center;\"><div class=\"vertical-text\">",
             "<div class=\"vertical-text__inner\" style=\"color:#2676ba;\">",
               etich_col_1r,"</div></div> </th>", 
         "</tr></thead>",sep=" ",collapse=" ") 
res  
}
 
corpo_1 <-  function(record){ # tutta la riga anche con colonna extra
  dime <- length(record)-1
  # filtro record for colouring the background
  templato <- list()
  # now patterns are 40
  templato[1:40] <- "<td style=\"text-align:center;\">";
  
  # end of changes
  templato[[1]] <- "<td style=\"text-align:center;background-color:#dbe7c2;\">";
  templato[[6]] <- "<td style=\"text-align:center;background-color:#f9b9b9;\">";
  templato[[9]] <- "<td style=\"text-align:center;background-color:#ee3557;\">";
  elem_good <- as.numeric(record[-1*c(1,dime-2,dime-1,dime,dime+1)])
  res <- paste(
  "<tr>",
   "<td style=\"text-align:left;\">", record[1],"</td>",
    paste(templato[elem_good],
        elem_good,"</td>",sep="",collapse=""),
   "<td style=\"text-align:center;\">",
         "<span  >",record[dime-2],"</span></td>",
  "<td style=\"text-align:center;\">",
            "<span  >",record[dime-1],"</span></td>",
  "<td style=\"text-align:center;\">", 
             "<span  >",record[dime],"</span></td>",
  paste(templato[[ as.numeric(record[dime+1]) ]], " ",
                "<span >",
               record[dime+1],
               "</span>",
              "</td>"),
  "</tr>",sep="")
  
  res
}

corpo_full <-  function(myTB){
  
  dimeR <- nrow(myTB)
  res<-"<tbody>"
  for(aux in 1:dimeR){
    recordcorre <-  corpo_1( unlist(myTB[aux,]))
    res <- paste(res,recordcorre,
                 sep="")
  } 
  paste(res,
        "</tbody>","</table>",sep="")
}

tabe_tot <- function(mydata, first_last_years="First/Last"){
  totcol <- ncol(mydata)-1
  intesta <- names(mydata)[-c(1,totcol-2,totcol-1,totcol,totcol+1)]
  res <-  testa_1(totcol)
  res <- paste(res, testa_2bis(etichetteH = intesta, 
                               etich_col_1r = first_last_years ),
               sep="")
  res <- paste(res, corpo_full(mydata),sep="")
  res
}

 
```

 
 
 
```{r compilePatterns,results='asis',eval=T}
estrattore <- as.logical((wkDF[,timeName] >= ptime_0) &  (wkDF[,timeName]<= ptime_t))
estrattore_1_n <- as.logical((wkDF[,timeName] == ptime_0) |   
                               (wkDF[,timeName]== ptime_t))

## original patterns
# myMSPat <- ms_pattern_ori(wkDF[estrattore,],
#                           timeName = timeName,
#                           typeIn= params$indiType)
# myMSPat_first_last <- ms_pattern_ori(wkDF[estrattore_1_n ,],
#                           timeName = timeName,
#                           typeIn= params$indiType)
# ### end of original patterns
### new 39+1 patterns
myMSPat <- ms_pattern_39(wkDF[estrattore,],
                          timeName = timeName)
myMSPat_first_last <- ms_pattern_39(wkDF[estrattore_1_n ,],
                          timeName = timeName)
## end of 39+1 new patterns

workMatSco <- myMSPat$res$mat_num_tags
workMatSco2 <- dplyr::bind_cols(myMSPat$res$mat_num_tags,
                            myMSPat_first_last$res$mat_num_tags[,2] )
# test
if(any(myMSPat$res$mat_num_tags[,1] != myMSPat_first_last$res$mat_num_tags[,1])){
  stop("Error:  countries do not match.")
}
```


```{r,results='asis',eval=T}
##
curCountries <- setdiff(names(wkDF),timeName)
posiMS  <- posiMS2 <- vector()
for(auxCC in curCountries){
    posiMS <-  c(posiMS,which(workMatSco$Country == auxCC))
    posiMS2 <-  c(posiMS2,which(workMatSco2$Country == auxCC))
    
}  
workMatSco <- workMatSco[posiMS,]
workMatSco2 <- workMatSco2[posiMS2,]
  
if(params$aggregation != "custom"){
  map2str <- convergEU_glb()[[params$aggregation]]$memberStates
}else{ # it's custom 3 october 2019
  map2str <- dplyr::tibble(MS = curCountries,
                           codeMS = curCountries)
}
## below is fine
for(aux in 1:nrow(workMatSco)){ 
    puntaMS <- which(map2str$codeMS ==   workMatSco$Country[aux ])
    workMatSco$Country[aux ] <- map2str$MS[puntaMS]
    puntaMS2 <- which(map2str$codeMS ==   workMatSco2$Country[aux ])
    workMatSco2$Country[aux ] <- map2str$MS[puntaMS]
    
}
mappaLongStri <- sapply(seleCount,function(vx){which(vx == nomiSele)})
seleEstresi <- nomiSeleExt[mappaLongStri]
workMatSco3 <- dplyr::filter(workMatSco2, Country %in% seleEstresi)



#{r,eval=TRUE,echo=F}
# temporaneo
# filter 
# debug(tabe_tot)
tabeHTMLfinal <- tabe_tot(workMatSco3, 
                          first_last_years = paste(ptime_0,"/", 
                                                   ptime_t,sep=""))



out_packed_list$patterns <- list(css="<style>\n.vertical-text {\n\tdisplay: inline-block;\n\toverflow: hidden;\n\twidth: 1.3em;\n}\n.vertical-text__inner {\n\tdisplay: inline-block;\n\twhite-space: nowrap;\n\tline-height: 1.5;\n\ttransform: translate(0,100%) rotate(-90deg);\n\ttransform-origin: 0 0;\n}\n\n.vertical-text__inner:after {\n\tcontent: \"\";\n\tdisplay: block;\n\tmargin: -1.5em 0 100%;\n}\n\n\nbody {\n\tfont: 11px/1 Arial, sans-serif;\n}\n\ntable {\n\tmargin-top: 1em;\n}\nth,td {\n\tborder: 1px solid;\n\ttext-align:center;\n\tfont-weight: normal;\n\tpadding: 0.5em;\n}\nhead{\n   color: blue;\n}\n</style>",
     html=tabeHTMLfinal)

cat(tabeHTMLfinal)
```

```{r,echo=F,eval=F}
# tests in progress to substitute the HTML table

 workMatSco2 %>%
  kableExtra::kbl() %>%
  kable_styling()

workMatSco3 <- dplyr::rename(workMatSco3, `#(1)` = Catching_up ,
                                          `#(9)` = Falling_away,
                                          `#(6)` = Diving )
#workMatSco3 %>%
#  kable() %>%
#  kable_styling()
tmpRR <- names(workMatSco3)
kable(workMatSco3,
      "html",col.names = kableExtra::linebreak(c(tmpRR),align="c"
                                               #,linebreaker="/"
                                               )) %>% 
  kableExtra::kable_styling(c("striped","bordered"), 
                            full_width = F, position="left") %>%
  kableExtra::row_spec(0, angle = 0)

```
 
 


<br><br>
Legend:    

 * Indicator type: `r params$indiType`   
 * dashed red lines: Member States    
 * solid black lines: EU average   
 




```{r legend1,echo=FALSE,fig.width=6,fig.height=5} 
refGGpat <- patt_legend_39()
out_packed_list$gridLegend <- refGGpat

grid.arrange(  refGGpat[[1]],
               nrow = 1, ncol=1,
      top= paste0("Patterns legend"),
      bottom = "Time",
      left= "Indicator value")
```

<br><br>

```{r legend2,echo=FALSE,fig.width=6,fig.height=5} 

grid.arrange(  refGGpat[[2]],
               nrow = 1, ncol=1,
      top= paste0("Patterns legend (continued)"),
      bottom = "Time",
      left= "Indicator value")
```


 
```{r OLDpattern,echo=FALSE,eval=FALSE,fig.width=8,fig.height=8} 
if(params$indiType == "highBest"){refGGpat <- patt_legend(indiType = "highBest")
} else{  refGGpat <- patt_legend(indiType = "lowBest")}
gridExtra::grid.arrange(  refGGpat,
               nrow = 1, ncol=1,
      top= paste0("Patterns legend (continued)"),
      bottom = "Time",
      left= "Indicator value")
out_packed_list$gridLegend <- refGGpat
```  
 
 


<!-- **Note:** 21 is none of the previous patterns and requires visual inspection.-->

<br>

Legend:    

  * Indicator type: `r params$indiType`     
  * dashed red lines: Member States   
  * solid black lines: EU average     
 
 
 
 
 
 
 
 
 
 
 
<br><br>

```{r demeaGraphSet,echo=FALSE,eval=T}
curCountries <- params$country
if(!is.na(otherCountries[1])){
  curCountries <- c(curCountries, otherCountries)
}
altezzaG <- 3 + 4 * (length(curCountries)/30)
#height was 6
```



### Total decrease and increase in the gap with the `r params$aggregation` mean  

The graph shows the sum of the yearly deviations from `r params$aggregation` unweighted average in each of the countries selected.

```{r demeaGraph,echo=FALSE,eval=T,fig.width=8,fig.height=altezzaG}
curCountries <- params$country
if(!is.na(otherCountries[1])){
  curCountries <- c(curCountries, otherCountries)
}

res_dev_pt  <- demea_change(wkDF,
                      timeName=timeName,
                      time_0 = ptime_0,
                      time_t = ptime_t,
                      sele_countries= curCountries,
                      doplot=TRUE)


out_packed_list$Tot_inc_dec <- res_dev_pt$res

print(res_dev_pt$res$res_graph)


```



```{r oldGraph2beSubstituted,echo=FALSE,eval=F}
curCountries <- params$country
if(!is.na(otherCountries[1])){
  curCountries <- c(curCountries, otherCountries)
}

res_dev_pt <- dev_mean_plot(wkDF,
                          timeName = timeName,
                          time_0 = ptime_0,
                          time_t = ptime_t,
                          countries = curCountries,  
                          indiType = params$indiType,
                          displace = 0.15,
                          axis_name_y = "Countries",
                          val_alpha  = 0.95,
                          debug=FALSE) 

print(res_dev_pt$res)
out_packed_list$Tot_inc_dec <- res_dev_pt$res

```





<br><br>


### Total gap  with respect to the best performer within each year  


The graph gives an overall idea of the distance of the Member States from the best performing country. It is calculated as the sum of the yearly deviations from the best performer. 
 

```{r}
res_dep_best <- departure_best(wkDF, timeName =timeName,
                          indiType = params$indiType) 

res_dep_best_plt <- departure_best_plot(
         cumulaDifVector = res_dep_best$res$cumulated_dif,
         mainCountry = params$country,
         countries = otherCountries,
         displace = 0.25,
         axis_name_y = "Countries",
         val_alpha  = 0.95,
         debug=FALSE)
 

print(res_dep_best_plt$res)
out_packed_list$Dep_best <- res_dep_best_plt$res

```












<br><br>

### Country ranking table

The table shows the country ranking in the `r params$aggregation` in each year, with 1 being the best performing country in `r params$aggregation` in a given year. 

<br><br>

```{r}
res_rank <- country_ranking(wkDF,timeName=timeName, time_0=ptime_0,
                            time_t= ptime_t, typeInd= params$indiType )$res
coloRR <- c(timeName,curCountries)
tmpRR <-  t(res_rank[,coloRR] )
if(nrow(tmpRR) > 2){
  matPosFinal <- tmpRR[-1,]
}else{
  matPosFinal <- rbind(tmpRR[-1,])
  dimnames(matPosFinal)  <- list(dimnames(tmpRR)[[1]][2],NULL)
}
kable(matPosFinal,"html",col.names = kableExtra::linebreak(c(tmpRR[1,]),align="c" )) %>% 
  kableExtra::kable_styling(c("striped","bordered"), full_width = F, position="left") %>%
  kableExtra::row_spec(0, angle = -60)

```

<br><br>


```{r,eval=FALSE}
if(ncol(tmpRR) > 10){
  print(tmpRR[,1:10])
  tmptmp <- lapply(seq(10,ncol(tmpRR),10),function(vx){
    cat("\n\n")
    print(tmpRR[,-c(1:vx)])
    })
}else{
  print(tmpRR)
} 
```



```{r,echo=FALSE,eval=T}
save(out_packed_list,file = out_packed_name)
```

